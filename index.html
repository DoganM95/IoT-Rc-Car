<!DOCTYPE html>
<html>

<head>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/101/three.min.js"></script>
    <!-- include socket.io client side script -->
</head>

<body>
    <h1>First run</h1>
    <div id="buttons">
        <button id="motorState">Run Da Motor</button> <!-- listen per eventlistener on any events -->
        <button id="servoLeftButton">Turn Servo Left</button>
        <button id="servoRightButton">Turn Servo Right</button>
    </div>

    <script>
        var socket = io(); //load socket.io-client and connect to the host that serves the page
        socket.emit("servoSocket", 1500); //initially center servo

        window.addEventListener("load", function () { //when page loads
            let motor = document.getElementById("motorState");
            let servoLeftElement = document.getElementById("servoLeftButton");
            let servoRightElement = document.getElementById("servoRightButton");
            let motorSpeed = 0; //Stop motor initially
            let servoAngle = 1500; //Center position intitially

            //Increments for modules
            let motorSpeedIncrement = 5;
            let servoAngleIncrement = 10;

            //Event Listeners:
            motor.addEventListener("mousedown", function () { //when button is pressed
                socket.emit("motorSocket", 255); //send motor-run action (on)
            });
            motor.addEventListener("mouseup", function () { //when mouse is released
                socket.emit("motorSocket", 0); //send motor-stop action (off)
            });
            servoLeftElement.addEventListener("click", function () { //when button is clicked
                socket.emit("servoSocket", 2500); //turn servo most-clockwise
            });
            servoRightElement.addEventListener("click", function () { //when button is clicked
                socket.emit("servoSocket", 500); //turn servo most anti-clockwise
            });

            socket.on("motorSpeedSocket", (data) => { //when motor-speed changes, receive the speed via socket 
                motorSpeed = data; //set motorSpeed's value to the current speed
                console.log("received current motorSpeed via socket: " + motorSpeed);
            });

            socket.on("servoAngleSocket", (data) => {
                servoAngle = data;
                console.log("received current servoAngle via Socket: " + servoAngle);
            });

            document.addEventListener("keydown", (key) => { //Keypress Event listener
                console.log("Key: " + key.keyCode + " pressed."); //log the pressed key
                switch (key.keyCode) { //switch statement for pressed key
                    case 40: //backwards
                        if (motorSpeed > 0) {
                            (async () => { socket.emit("motorSocket", (motorSpeed - motorSpeedIncrement)); })(); //increase motorSpeed by motorSpeedIncrement's value
                        }
                        break;
                    case 38: //forwards
                        if (motorSpeed < 255) {
                            (async () => { socket.emit("motorSocket", (motorSpeed + motorSpeedIncrement)); })(); //decrease motorSpeed by motorSpeedIncrement's value
                        }
                        break;
                    case 53: //Full Speed or stop (like play pause)
                        if (motorSpeed > 0) {
                            socket.emit("motorSocket", 0); //stops motor, if motor is running
                        }
                        if (motorSpeed == 0) {
                            socket.emit("motorSocket", 255); //max-speeds motor, if it was off
                        }
                        break;
                    //Servo direction control
                    case 37:
                        if (servoAngle > 500) {
                            (async () => {
                                socket.emit("servoSocket", servoAngle - servoAngleIncrement)
                                servoAngle -= servoAngleIncrement;
                            })();
                        }
                        break;
                    case 39:
                        if (servoAngle < 2500) {
                            (async () => {
                                socket.emit("servoSocket", servoAngle + servoAngleIncrement)
                                servoAngle += servoAngleIncrement;
                            })();
                        }
                        break;
                }
            })
        });

        //Chrome sensoring tests

        // Promise.all([navigator.permissions.query({ name: "accelerometer" }),
        // navigator.permissions.query({ name: "magnetometer" }),
        // navigator.permissions.query({ name: "gyroscope" })])
        //     .then(results => {
        //         if (results.every(result => result.state === "granted")) {
        //             const options = { frequency: 60, referenceFrame: 'device' };
        //             const sensor = new AbsoluteOrientationSensor(options);

        //             sensor.addEventListener('reading', () => {
        //                 // model is a Three.js object instantiated elsewhere.
        //                 model.quaternion.fromArray(sensor.quaternion).inverse();
        //             });
        //             sensor.AddEventListener('error', error => {
        //                 if (event.error.name == 'NotReadableError') {
        //                     console.log("Sensor is not available.");
        //                 }
        //             });
        //             sensor.start();

        //         } else {
        //             console.log("No permissions to use AbsoluteOrientationSensor.");
        //         }
        //     });


        // // Update mesh rotation using quaternion.
        // const sensorAbs = new AbsoluteOrientationSensor();
        // sensorAbs.onreading = () => torus.quaternion.fromArray(sensorAbs.quaternion);
        // sensorAbs.start();

        // // Update mesh rotation using rotation matrix.
        // const sensorRel = new RelativeOrientationSensor();
        // let rotationMatrix = new Float32Array(16);
        // sensor_rel.onreading = () => {
        //     sensorRel.populateMatrix(rotationMatrix);
        //     torus.matrix.fromArray(rotationMatrix);
        // }
        // sensorRel.start();
    </script>
</body>

</html>